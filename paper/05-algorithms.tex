\section{Algorithm}\label{sec:algorithms}
\todo{two separate algorithms for testing and ranking}
We present the \algoFAIR algorithm (\S\ref{subsec:algorithm-description}) and prove it is correct (\S\ref{subsec:algorithm-correctness}).

\subsection{Algorithm Description}\label{subsec:algorithm-description}

\textbf{Algorithm \algoFAIRBF}, presented in Algorithm~\ref{alg:fair}, solves the {\sc Fair Top-$k$ Ranking} problem.
%
As input, FA*IR takes 
the expected size $k$ of the ranking to be returned,
the qualifications $q_i$, 
indicator variables $g_i$ indicating if element $i$ is protected,
the target minimum proportion $p$ of protected candidates, and
the adjusted significance level $\alphaadj$.

First, the algorithm uses $q_i$ to create two priority queues with up to $k$ candidates each: $P_0$ for the non-protected candidates and $P_1$ for the protected candidates.
%
Next (lines \ref{alg:fair:mstart}-\ref{alg:fair:mend}), the algorithm derives a ranked group fairness table similar to Table~\ref{tbl:ranked_group_fairness_table}, i.e., for each position it computes the minimum number of protected candidates, given $p$, $k$ and $\alphaadj$.
%
Then, \algoFAIR greedily constructs a ranking subject to candidate qualifications, and minimum protected elements required, resembling the method by~\citet{celis2017ranking} for the case of a single protected attribute (the main difference being that we compute the table $m$, while \cite{celis2017ranking} assumes it is given).
%
If the previously computed table $m$ demands a protected candidate at the current position, the algorithm appends the best candidate from $P_1$ to the ranking (Lines \ref{alg:fair:pstart}-\ref{alg:fair:pend}); otherwise, it appends the best candidate from $P_0 \cup P_1$ (Lines \ref{alg:fair:anystart}-\ref{alg:fair:anyend}).

\algoFAIR has running time $O(n + k \log k)$; which includes building the two $O(k)$ size priority queues from $n$ items and processing them to obtain the ranking, where we assume $k < O(n/\log n)$. 
%
If we already have two ranked lists for both classes of elements, \algoFAIR can avoid the first step and obtain the top-$k$ in $O(k \log k)$ time.
%
Our method is applicable as long as there is a protected group and there are enough candidates from that group; if there are $k$ from each group, the algorithm is guaranteed to succeed, otherwise the ``head'' of the ranking will satisfy the ranked group fairness constraint, but the ``tail'' of the ranking may not.

\begin{algorithm}[h]
	%\caption{Algorithm \algoFAIR, finding a ranking that maximizes utility subject to in-group monotonicity and ranked group fairness constraints.}
	\caption{Algorithm \algoFAIR finds a ranking that maximizes utility subject to in-group monotonicity and ranked group fairness constraints. Checks for special cases (e.g., insufficient candidates of a class) are not included for clarity.}
	\label{alg:fair}  % But whenever possible refer to this algo. by name not number
	\small
	\AlgInput{$k \in [n]$, the size of the list to return; $\forall~i \in [n]$: $q_i$, the qualifications for candidate $i$, and $g_i$ an indicator that is 1 iff candidate $i$ is protected; $p \in ]0,1[$, the minimum proportion of protected elements; $\alphaadj \in ]0,1[$, the adjusted significance for each fair representation test.}
	\AlgOutput{$\tau$ satisfying the group fairness condition with parameters $p, \sigma$, and maximizing utility.}
	%\AlgComment{compute min. protected candidates per position}
	$P_0, P_1 \leftarrow$ empty priority queues with bounded capacity $k$\\
	\For{$i \leftarrow 1$ \KwTo $n$}{
		insert $i$ with value $q_i$ in priority queue $P_{g_i}$ \\
	}
	\For{$i \leftarrow 1$ \KwTo $k$}{ \label{alg:fair:mstart}
		$m[i] \leftarrow F^{-1}(\alphaadj; i, p)$ \\
	}\label{alg:fair:mend}
	%\AlgComment{create fair ranking}
	$(t_p, t_n) \leftarrow (0, 0)$ \\
	\While{$t_p + t_n < k$}{
		\eIf{$t_p < m[t_p + t_n + 1]$}{
			\AlgComment{add a protected candidate}
			$t_p \leftarrow t_p + 1$ \\ \label{alg:fair:pstart}
			$\tau[t_p + t_n] \leftarrow \operatorname{dequeue}(P_1)$ \\  \label{alg:fair:pend}
		}{
		\AlgComment{add the best candidate available}
		\eIf{$q(\operatorname{peek}(P_1)) \ge q(\operatorname{peek}(P_0))$} { \label{alg:fair:anystart}
			%\AlgComment{best one is a protected candidate}
			$t_p \leftarrow t_p + 1$ \\
			$\tau[t_p + t_n] \leftarrow \operatorname{dequeue}(P_1)$ \\
			
		}{
		%\AlgComment{best one is a non-protected candidate}
		$t_n \leftarrow t_n + 1$ \\
		$\tau[t_p + t_n] \leftarrow \operatorname{dequeue}(P_0)$ \\
	} \label{alg:fair:anyend}
}

}
\Return{$\tau$}
\end{algorithm}
\vspace{-3mm}

\subsection{Algorithm Correctness}\label{subsec:algorithm-correctness}

By construction, a ranking $\tau$ generated by \algoFAIR satisfies in-group monotonicity, because protected and non-protected candidates are selected by decreasing qualifications.
%
It also satisfies the ranked group fairness constraint, because for every prefix of size $i$ the list, the number of protected candidates is at least $m[i]$. 
%
What we must prove is that $\tau$ achieves optimal selection utility, and that it maximizes ordering utility. 
%
This is done in the following lemmas.

\begin{lemma}\label{lemma:across}
	If a ranking satisfies the in-group monotonicity constraint, then the utility loss (ordering or selection utility different from zero) can only happen across protected/non-protected groups.
\end{lemma}

\begin{proof}
	This comes directly from Definition~\ref{def:inGroupMonotonicity} given that for two elements $i,j$, the only case in which $r(i,\tau) < r(j,\tau) \wedge q_i < q_j$ is when $g_i \ne g_j$.
\end{proof}

\begin{lemma}
	The optimal selection utility among rankings satisfying in-group monotonicity (\ref{problem:constraint-monotonicity}) and ranked group fairness (\ref{problem:constraint-rank}), is either zero, or is due to a non-protected candidate ranked below a less qualified protected candidate.
\end{lemma}

\begin{proof}
	Let $i,j$ be the two elements that attain the optimal selection utility, with $i \in \tau, j \in [n] \backslash \tau$.
	%
	We will prove by contradiction: let us assume $i$ is a non-protected element ($g_i=0$) and $j$ is a protected element ($g_j=1$). 
	%
	By in-group monotonicity, we know $i$ is the last non-protected element in $\tau$. Let us swap $i$ and $j$, moving $i$ outside $\tau$ and $j$ inside the ranking, and then moving down $j$ if necessary to place it in the correct ordering among the protected elements below its position (given that $i$ is the last non-protected element in $\tau$). 
	%
	The new ranking continues to satisfy in-group monotonicity as well as ranked group fairness (as it has not decreased the number of protected elements at any position in the ranking), and has a larger selection utility. 
	%
	This is a contradiction because the selection utility was optimal. Hence, $i$ is a protected element and $j$ a non-protected element.
\end{proof}

\begin{lemma}\label{lemma:number-protected-implies-selfairness} %[Elements inside/outside a ranking are determined by $\tau_p$]
	Given two rankings $\rho, \tau$ satisfying in-group monotonicity (\ref{problem:constraint-monotonicity}), if they have the same number of protected elements $\rho_p = \tau_p$, then both rankings contain the same $k$ elements (possibly in different order), and hence both rankings have the same selection utility.
\end{lemma}

\begin{proof}
	Both rankings contain a prefix of size $\tau_p$ of the list of protected candidates ordered by decreasing qualifications, and a prefix of size $k - \tau_p$ of the list of non-protected candidates ordered by decreasing qualifications. 
	%
	Hence, $\forall i \in [n], i \in \tau \Leftrightarrow i \in \rho$, so the elements not included in the rankings are also the same elements, and the selection utility of both rankings is the same.
\end{proof}

The previous lemma means selection utility is determined by the number of protected candidates in a ranking.

\begin{lemma}\label{lemma:fair-optimal-selection}
	Algorithm \algoFAIR achieves optimal selection utility among rankings satisfying in-group monotonicity (\ref{problem:constraint-monotonicity}) and ranked group fairness (\ref{problem:constraint-rank}).
\end{lemma}

\begin{proof}
	Let $\tau$ be the ranking produced by \algoFAIR, and $\tau^*$ be the ranking achieving the optimal selection utility. We will prove that $\tau_p = \tau^*_p$ by contradiction.
	%
	Suppose $\tau_p < \tau^*_p$. Then, we could take the least qualified protected element in $\tau^*_p$ and swap it with the most qualified non-protected element in $[n] \backslash \tau^*_p$, re-ordering as needed. This would increase selection utility and still satisfy the constraints, which is a contradiction with the fact that $\tau^*_p$ achieved the optimal selection utility.
	%
	Suppose $\tau_p > \tau^*_p$. Then, at the position at which the least qualified protected element in $\tau$ is found, we could have placed a non-protected element with higher qualifications, as $\tau^*$ satisfies ranked group fairness and has less protected elements. This is a contradiction with the way in which \algoFAIR operates, as it only places a protected element with lower qualifications when needed to satisfy ranked group fairness.
	%
	Hence, $\tau_p = \tau^*_p$ and by Lemma~\ref{lemma:number-protected-implies-selfairness} it achieves the same selection utility.
\end{proof}

\begin{lemma}
	Algorithm \algoFAIR maximizes ordering utility among rankings satisfying in-group monotonicity (\ref{problem:constraint-monotonicity}), ranked group fairness (\ref{problem:constraint-rank}), and achieving optimal selection utility (\ref{problem:optimal-sel}).
\end{lemma}

\begin{proof}
	By lemmas~\ref{lemma:number-protected-implies-selfairness} and \ref{lemma:fair-optimal-selection} we know that satisfying the constraints and achieving optimal selection utility implies having a specific number of protected elements $\tau^*_p$.
	%
	Hence, we need to show that among rankings having this number of protected elements, \algoFAIR achieves the maximum ordering utility.
	%
	By Lemma~\ref{lemma:across} we know that loss of ordering utility is due only to non-protected elements placed below less qualified protected elements. 
	%
	However, we know that in \algoFAIR this only happens when necessary to satisfy ranked group fairness, and having less protected elements at any given position than the ranking produced by \algoFAIR would violate the ranked group fairness constraint.
	%However, we know that in \algoFAIR this only happens when necessary to satisfy ranked group fairness, similarly to~\cite{celis2017ranking}, and by the same arguments, having less protected elements at any given position than the ranking produced by \algoFAIR would violate the ranked group fairness constraint.
\end{proof}

\todo{put algorithm complexity}


